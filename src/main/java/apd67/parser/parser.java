
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20150326
//----------------------------------------------------

package apd67.parser;

import java.util.LinkedList;
import apd67.ast.*;
import apd67.lexer.Token;
import apd67.util.exception.*;
import java_cup.runtime.Symbol;

/** CUP v0.11b 20150326 generated parser.
  */
public class parser
 extends java_cup.runtime.lr_parser {

  @Override
  public final Class<?> getSymbolContainer() {
    return sym.class;
  }

  /** Default constructor. */
  @Deprecated
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner and a SymbolFactory. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\161\000\002\002\004\000\002\003\003\000\002\003" +
    "\004\000\002\002\005\000\002\002\004\000\002\002\006" +
    "\000\002\002\005\000\002\023\003\000\002\023\004\000" +
    "\002\023\004\000\002\022\004\000\002\022\005\000\002" +
    "\005\003\000\002\005\004\000\002\026\003\000\002\026" +
    "\003\000\002\026\003\000\002\026\003\000\002\026\003" +
    "\000\002\026\004\000\002\027\005\000\002\027\004\000" +
    "\002\027\003\000\002\027\004\000\002\004\006\000\002" +
    "\004\005\000\002\007\005\000\002\007\004\000\002\014" +
    "\005\000\002\014\004\000\002\030\003\000\002\030\004" +
    "\000\002\030\004\000\002\030\005\000\002\013\005\000" +
    "\002\013\007\000\002\006\003\000\002\006\005\000\002" +
    "\006\004\000\002\021\004\000\002\020\003\000\002\020" +
    "\005\000\002\015\003\000\002\015\003\000\002\017\003" +
    "\000\002\017\005\000\002\016\003\000\002\016\004\000" +
    "\002\033\004\000\002\011\003\000\002\011\005\000\002" +
    "\032\005\000\002\010\003\000\002\010\006\000\002\012" +
    "\003\000\002\012\003\000\002\012\004\000\002\040\005" +
    "\000\002\037\005\000\002\037\007\000\002\041\005\000" +
    "\002\041\006\000\002\041\005\000\002\041\004\000\002" +
    "\031\003\000\002\031\003\000\002\031\005\000\002\031" +
    "\006\000\002\031\005\000\002\031\006\000\002\031\004" +
    "\000\002\031\003\000\002\035\004\000\002\035\004\000" +
    "\002\034\005\000\002\034\005\000\002\034\005\000\002" +
    "\034\005\000\002\034\005\000\002\034\005\000\002\034" +
    "\005\000\002\034\005\000\002\034\005\000\002\034\005" +
    "\000\002\034\005\000\002\034\005\000\002\034\005\000" +
    "\002\034\005\000\002\034\006\000\002\024\005\000\002" +
    "\025\007\000\002\025\010\000\002\025\006\000\002\025" +
    "\005\000\002\025\003\000\002\025\006\000\002\025\005" +
    "\000\002\036\005\000\002\036\005\000\002\043\003\000" +
    "\002\043\006\000\002\043\011\000\002\043\010\000\002" +
    "\042\003\000\002\042\003\000\002\042\003\000\002\042" +
    "\003\000\002\042\003\000\002\042\003\000\002\042\005" +
    "\000\002\042\004\000\002\042\005\000\002\044\003" });

  /** Access to production table. */
  @Override
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\273\000\010\046\005\054\014\060\013\001\002\000" +
    "\004\002\275\001\002\000\004\060\013\001\002\000\006" +
    "\046\ufff5\060\ufff5\001\002\000\006\002\ufffa\060\ufffa\001" +
    "\002\000\004\013\021\001\002\000\006\046\005\060\013" +
    "\001\002\000\006\002\000\060\013\001\002\000\100\004" +
    "\uff91\005\uff91\013\uff91\014\uff91\015\uff91\016\uff91\017\uff91" +
    "\020\uff91\021\uff91\022\uff91\023\uff91\024\uff91\025\uff91\026" +
    "\uff91\027\uff91\030\uff91\031\uff91\032\uff91\033\uff91\034\uff91" +
    "\035\uff91\036\uff91\037\uff91\040\uff91\041\uff91\042\uff91\043" +
    "\uff91\045\uff91\046\uff91\051\uff91\060\uff91\001\002\000\004" +
    "\060\013\001\002\000\004\013\021\001\002\000\006\002" +
    "\uffff\060\013\001\002\000\004\013\021\001\002\000\010" +
    "\002\ufffb\021\040\060\ufffb\001\002\000\006\014\024\060" +
    "\013\001\002\000\004\014\036\001\002\000\004\021\025" +
    "\001\002\000\012\002\uffe4\015\uffe4\021\uffe4\060\uffe4\001" +
    "\002\000\006\006\031\007\030\001\002\000\016\002\uffd5" +
    "\014\uffd5\015\uffd5\017\uffd5\023\uffd5\060\uffd5\001\002\000" +
    "\010\014\uffdf\017\033\023\032\001\002\000\036\002\uffd6" +
    "\004\uffd6\005\uffd6\014\uffd6\015\uffd6\016\uffd6\017\uffd6\022" +
    "\uffd6\023\uffd6\041\uffd6\042\uffd6\043\uffd6\051\uffd6\060\uffd6" +
    "\001\002\000\036\002\uffd7\004\uffd7\005\uffd7\014\uffd7\015" +
    "\uffd7\016\uffd7\017\uffd7\022\uffd7\023\uffd7\041\uffd7\042\uffd7" +
    "\043\uffd7\051\uffd7\060\uffd7\001\002\000\004\060\013\001" +
    "\002\000\004\020\034\001\002\000\016\002\uffd4\014\uffd4" +
    "\015\uffd4\017\uffd4\023\uffd4\060\uffd4\001\002\000\004\014" +
    "\uffde\001\002\000\012\002\uffe5\015\uffe5\021\uffe5\060\uffe5" +
    "\001\002\000\006\002\ufffc\060\ufffc\001\002\000\006\006" +
    "\031\007\030\001\002\000\010\002\uffda\015\uffda\060\uffda" +
    "\001\002\000\014\002\uffd9\015\uffd9\017\033\023\043\060" +
    "\uffd9\001\002\000\006\006\031\007\030\001\002\000\010" +
    "\002\uffd8\015\uffd8\060\uffd8\001\002\000\010\002\ufffd\021" +
    "\040\060\ufffd\001\002\000\006\002\ufffe\060\ufffe\001\002" +
    "\000\006\002\ufff8\060\ufff8\001\002\000\006\046\ufff4\060" +
    "\ufff4\001\002\000\006\002\ufff9\060\ufff9\001\002\000\006" +
    "\015\055\021\040\001\002\000\004\015\055\001\002\000" +
    "\006\002\uffe8\060\uffe8\001\002\000\020\004\072\015\055" +
    "\016\065\042\067\043\064\051\056\060\013\001\002\000" +
    "\006\023\uffa3\041\uffa3\001\002\000\006\016\267\043\064" +
    "\001\002\000\024\004\ufff3\005\ufff3\015\ufff3\016\ufff3\022" +
    "\ufff3\042\ufff3\043\ufff3\051\ufff3\060\ufff3\001\002\000\024" +
    "\004\uffef\005\uffef\015\uffef\016\uffef\022\uffef\042\uffef\043" +
    "\uffef\051\uffef\060\uffef\001\002\000\024\004\ufff1\005\ufff1" +
    "\015\ufff1\016\ufff1\022\ufff1\042\ufff1\043\ufff1\051\ufff1\060" +
    "\ufff1\001\002\000\006\023\255\041\256\001\002\000\034" +
    "\010\106\011\115\012\112\013\104\015\120\016\uffe3\022" +
    "\252\025\110\044\103\056\107\060\013\061\113\062\105" +
    "\001\002\000\026\002\uffc2\004\uffc2\005\uffc2\015\uffc2\016" +
    "\uffc2\022\uffc2\042\uffc2\043\uffc2\051\uffc2\060\uffc2\001\002" +
    "\000\006\017\245\041\246\001\002\000\030\010\106\011" +
    "\115\012\112\013\104\015\120\025\110\044\103\056\107" +
    "\060\013\061\113\062\105\001\002\000\024\004\ufff2\005" +
    "\ufff2\015\ufff2\016\ufff2\022\ufff2\042\ufff2\043\ufff2\051\ufff2" +
    "\060\ufff2\001\002\000\012\013\210\017\uff9e\021\211\041" +
    "\uff9e\001\002\000\030\010\106\011\115\012\112\013\104" +
    "\015\120\025\110\044\103\056\107\060\013\061\113\062" +
    "\105\001\002\000\024\004\ufff0\005\ufff0\015\ufff0\016\ufff0" +
    "\022\ufff0\042\ufff0\043\ufff0\051\ufff0\060\ufff0\001\002\000" +
    "\022\004\072\015\055\016\uffeb\022\100\042\067\043\uffeb" +
    "\051\056\060\013\001\002\000\004\016\076\001\002\000" +
    "\026\002\uffc3\004\uffc3\005\uffc3\015\uffc3\016\uffc3\022\uffc3" +
    "\042\uffc3\043\uffc3\051\uffc3\060\uffc3\001\002\000\006\016" +
    "\uffec\043\uffec\001\002\000\020\004\072\015\055\016\uffea" +
    "\042\067\043\uffea\051\056\060\013\001\002\000\006\016" +
    "\uffed\043\uffed\001\002\000\070\004\uffc0\005\uffc0\014\uffc0" +
    "\015\uffc0\016\uffc0\017\uffc0\020\uffc0\022\uffc0\023\uffc0\024" +
    "\uffc0\025\uffc0\026\uffc0\027\uffc0\030\uffc0\031\uffc0\032\uffc0" +
    "\033\uffc0\034\uffc0\035\uffc0\036\uffc0\037\uffc0\040\uffc0\042" +
    "\uffc0\043\uffc0\045\uffc0\051\uffc0\060\uffc0\001\002\000\004" +
    "\013\204\001\002\000\030\010\106\011\115\012\112\013" +
    "\104\015\120\025\110\044\103\056\107\060\013\061\113" +
    "\062\105\001\002\000\070\004\uff96\005\uff96\014\uff96\015" +
    "\uff96\016\uff96\017\uff96\020\uff96\022\uff96\023\uff96\024\uff96" +
    "\025\uff96\026\uff96\027\uff96\030\uff96\031\uff96\032\uff96\033" +
    "\uff96\034\uff96\035\uff96\036\uff96\037\uff96\040\uff96\042\uff96" +
    "\043\uff96\045\uff96\051\uff96\060\uff96\001\002\000\070\004" +
    "\uff9a\005\uff9a\014\uff9a\015\uff9a\016\uff9a\017\uff9a\020\uff9a" +
    "\022\uff9a\023\uff9a\024\uff9a\025\uff9a\026\uff9a\027\uff9a\030" +
    "\uff9a\031\uff9a\032\uff9a\033\uff9a\034\uff9a\035\uff9a\036\uff9a" +
    "\037\uff9a\040\uff9a\042\uff9a\043\uff9a\045\uff9a\051\uff9a\060" +
    "\uff9a\001\002\000\070\004\uff98\005\uff98\014\uff98\015\uff98" +
    "\016\uff98\017\uff98\020\uff98\022\uff98\023\uff98\024\uff98\025" +
    "\uff98\026\uff98\027\uff98\030\uff98\031\uff98\032\uff98\033\uff98" +
    "\034\uff98\035\uff98\036\uff98\037\uff98\040\uff98\042\uff98\043" +
    "\uff98\045\uff98\051\uff98\060\uff98\001\002\000\032\010\106" +
    "\011\115\012\112\013\104\015\120\025\110\044\103\056" +
    "\107\057\200\060\013\061\113\062\105\001\002\000\070" +
    "\004\uffba\005\uffba\014\uffba\015\uffba\016\uffba\017\uffba\020" +
    "\uffba\022\uffba\023\uffba\024\uffba\025\uffba\026\uffba\027\uffba" +
    "\030\uffba\031\uffba\032\uffba\033\uffba\034\uffba\035\uffba\036" +
    "\uffba\037\uffba\040\uffba\042\uffba\043\uffba\045\uffba\051\uffba" +
    "\060\uffba\001\002\000\030\010\106\011\115\012\112\013" +
    "\104\015\120\025\110\044\103\056\107\060\013\061\113" +
    "\062\105\001\002\000\070\004\uff97\005\uff97\014\uff97\015" +
    "\uff97\016\uff97\017\uff97\020\uff97\022\uff97\023\uff97\024\uff97" +
    "\025\uff97\026\uff97\027\uff97\030\uff97\031\uff97\032\uff97\033" +
    "\uff97\034\uff97\035\uff97\036\uff97\037\uff97\040\uff97\042\uff97" +
    "\043\uff97\045\uff97\051\uff97\060\uff97\001\002\000\052\004" +
    "\072\015\055\017\140\024\144\025\135\026\131\027\136" +
    "\030\127\031\132\032\143\033\134\034\137\035\133\036" +
    "\142\037\141\040\130\042\067\045\126\051\056\060\013" +
    "\001\002\000\070\004\uff99\005\uff99\014\uff99\015\uff99\016" +
    "\uff99\017\uff99\020\uff99\022\uff99\023\uff99\024\uff99\025\uff99" +
    "\026\uff99\027\uff99\030\uff99\031\uff99\032\uff99\033\uff99\034" +
    "\uff99\035\uff99\036\uff99\037\uff99\040\uff99\042\uff99\043\uff99" +
    "\045\uff99\051\uff99\060\uff99\001\002\000\072\004\uff95\005" +
    "\uff95\013\170\014\uff95\015\uff95\016\uff95\017\uff95\020\uff95" +
    "\022\uff95\023\uff95\024\uff95\025\uff95\026\uff95\027\uff95\030" +
    "\uff95\031\uff95\032\uff95\033\uff95\034\uff95\035\uff95\036\uff95" +
    "\037\uff95\040\uff95\042\uff95\043\uff95\045\uff95\051\uff95\060" +
    "\uff95\001\002\000\070\004\uffc1\005\uffc1\014\uffc1\015\uffc1" +
    "\016\uffc1\017\uffc1\020\uffc1\022\uffc1\023\uffc1\024\uffc1\025" +
    "\uffc1\026\uffc1\027\uffc1\030\uffc1\031\uffc1\032\uffc1\033\uffc1" +
    "\034\uffc1\035\uffc1\036\uffc1\037\uffc1\040\uffc1\042\uffc1\043" +
    "\uffc1\045\uffc1\051\uffc1\060\uffc1\001\002\000\034\010\106" +
    "\011\115\012\112\013\104\015\120\016\122\023\121\025" +
    "\110\044\103\056\107\060\013\061\113\062\105\001\002" +
    "\000\004\016\167\001\002\000\070\004\uff93\005\uff93\014" +
    "\uff93\015\uff93\016\uff93\017\uff93\020\uff93\022\uff93\023\uff93" +
    "\024\uff93\025\uff93\026\uff93\027\uff93\030\uff93\031\uff93\032" +
    "\uff93\033\uff93\034\uff93\035\uff93\036\uff93\037\uff93\040\uff93" +
    "\042\uff93\043\uff93\045\uff93\051\uff93\060\uff93\001\002\000" +
    "\004\016\166\001\002\000\050\014\uffdd\016\uffdd\017\140" +
    "\022\uffdd\023\125\024\144\025\135\026\131\027\136\030" +
    "\127\031\132\032\143\033\134\034\137\035\133\036\142" +
    "\037\141\040\130\045\126\001\002\000\036\010\106\011" +
    "\115\012\112\013\104\014\uffdb\015\120\016\uffdb\022\uffdb" +
    "\025\110\044\103\056\107\060\013\061\113\062\105\001" +
    "\002\000\030\010\106\011\115\012\112\013\104\015\120" +
    "\025\110\044\103\056\107\060\013\061\113\062\105\001" +
    "\002\000\030\010\106\011\115\012\112\013\104\015\120" +
    "\025\110\044\103\056\107\060\013\061\113\062\105\001" +
    "\002\000\030\010\106\011\115\012\112\013\104\015\120" +
    "\025\110\044\103\056\107\060\013\061\113\062\105\001" +
    "\002\000\030\010\106\011\115\012\112\013\104\015\120" +
    "\025\110\044\103\056\107\060\013\061\113\062\105\001" +
    "\002\000\030\010\106\011\115\012\112\013\104\015\120" +
    "\025\110\044\103\056\107\060\013\061\113\062\105\001" +
    "\002\000\030\010\106\011\115\012\112\013\104\015\120" +
    "\025\110\044\103\056\107\060\013\061\113\062\105\001" +
    "\002\000\030\010\106\011\115\012\112\013\104\015\120" +
    "\025\110\044\103\056\107\060\013\061\113\062\105\001" +
    "\002\000\030\010\106\011\115\012\112\013\104\015\120" +
    "\025\110\044\103\056\107\060\013\061\113\062\105\001" +
    "\002\000\030\010\106\011\115\012\112\013\104\015\120" +
    "\025\110\044\103\056\107\060\013\061\113\062\105\001" +
    "\002\000\030\010\106\011\115\012\112\013\104\015\120" +
    "\025\110\044\103\056\107\060\013\061\113\062\105\001" +
    "\002\000\030\010\106\011\115\012\112\013\104\015\120" +
    "\025\110\044\103\056\107\060\013\061\113\062\105\001" +
    "\002\000\030\010\106\011\115\012\112\013\104\015\120" +
    "\025\110\044\103\056\107\060\013\061\113\062\105\001" +
    "\002\000\030\010\106\011\115\012\112\013\104\015\120" +
    "\025\110\044\103\056\107\060\013\061\113\062\105\001" +
    "\002\000\030\010\106\011\115\012\112\013\104\015\120" +
    "\025\110\044\103\056\107\060\013\061\113\062\105\001" +
    "\002\000\030\010\106\011\115\012\112\013\104\015\120" +
    "\025\110\044\103\056\107\060\013\061\113\062\105\001" +
    "\002\000\070\004\uffb7\005\uffb7\014\uffb7\015\uffb7\016\uffb7" +
    "\017\140\020\uffb7\022\uffb7\023\uffb7\024\uffb7\025\uffb7\026" +
    "\131\027\136\030\127\031\uffb7\032\uffb7\033\uffb7\034\uffb7" +
    "\035\uffb7\036\uffb7\037\uffb7\040\uffb7\042\uffb7\043\uffb7\045" +
    "\126\051\uffb7\060\uffb7\001\002\000\070\004\uffb0\005\uffb0" +
    "\014\uffb0\015\uffb0\016\uffb0\017\140\020\uffb0\022\uffb0\023" +
    "\uffb0\024\144\025\135\026\131\027\136\030\127\031\uffb0" +
    "\032\uffb0\033\uffb0\034\uffb0\035\uffb0\036\uffb0\037\uffb0\040" +
    "\uffb0\042\uffb0\043\uffb0\045\126\051\uffb0\060\uffb0\001\002" +
    "\000\070\004\uffac\005\uffac\014\uffac\015\uffac\016\uffac\017" +
    "\140\020\uffac\022\uffac\023\uffac\024\144\025\135\026\131" +
    "\027\136\030\127\031\132\032\143\033\134\034\137\035" +
    "\uffac\036\uffac\037\uffac\040\uffac\042\uffac\043\uffac\045\126" +
    "\051\uffac\060\uffac\001\002\000\070\004\uffab\005\uffab\014" +
    "\uffab\015\uffab\016\uffab\017\140\020\uffab\022\uffab\023\uffab" +
    "\024\144\025\135\026\131\027\136\030\127\031\132\032" +
    "\143\033\134\034\137\035\133\036\142\037\uffab\040\uffab" +
    "\042\uffab\043\uffab\045\126\051\uffab\060\uffab\001\002\000" +
    "\042\017\140\020\152\024\144\025\135\026\131\027\136" +
    "\030\127\031\132\032\143\033\134\034\137\035\133\036" +
    "\142\037\141\040\130\045\126\001\002\000\070\004\uffa9" +
    "\005\uffa9\014\uffa9\015\uffa9\016\uffa9\017\uffa9\020\uffa9\022" +
    "\uffa9\023\uffa9\024\uffa9\025\uffa9\026\uffa9\027\uffa9\030\uffa9" +
    "\031\uffa9\032\uffa9\033\uffa9\034\uffa9\035\uffa9\036\uffa9\037" +
    "\uffa9\040\uffa9\042\uffa9\043\uffa9\045\uffa9\051\uffa9\060\uffa9" +
    "\001\002\000\070\004\uffae\005\uffae\014\uffae\015\uffae\016" +
    "\uffae\017\140\020\uffae\022\uffae\023\uffae\024\144\025\135" +
    "\026\131\027\136\030\127\031\uffae\032\uffae\033\uffae\034" +
    "\uffae\035\uffae\036\uffae\037\uffae\040\uffae\042\uffae\043\uffae" +
    "\045\126\051\uffae\060\uffae\001\002\000\070\004\uffb3\005" +
    "\uffb3\014\uffb3\015\uffb3\016\uffb3\017\140\020\uffb3\022\uffb3" +
    "\023\uffb3\024\uffb3\025\uffb3\026\uffb3\027\uffb3\030\uffb3\031" +
    "\uffb3\032\uffb3\033\uffb3\034\uffb3\035\uffb3\036\uffb3\037\uffb3" +
    "\040\uffb3\042\uffb3\043\uffb3\045\uffb3\051\uffb3\060\uffb3\001" +
    "\002\000\070\004\uffb6\005\uffb6\014\uffb6\015\uffb6\016\uffb6" +
    "\017\140\020\uffb6\022\uffb6\023\uffb6\024\uffb6\025\uffb6\026" +
    "\131\027\136\030\127\031\uffb6\032\uffb6\033\uffb6\034\uffb6" +
    "\035\uffb6\036\uffb6\037\uffb6\040\uffb6\042\uffb6\043\uffb6\045" +
    "\126\051\uffb6\060\uffb6\001\002\000\070\004\uffaf\005\uffaf" +
    "\014\uffaf\015\uffaf\016\uffaf\017\140\020\uffaf\022\uffaf\023" +
    "\uffaf\024\144\025\135\026\131\027\136\030\127\031\uffaf" +
    "\032\uffaf\033\uffaf\034\uffaf\035\uffaf\036\uffaf\037\uffaf\040" +
    "\uffaf\042\uffaf\043\uffaf\045\126\051\uffaf\060\uffaf\001\002" +
    "\000\070\004\uffad\005\uffad\014\uffad\015\uffad\016\uffad\017" +
    "\140\020\uffad\022\uffad\023\uffad\024\144\025\135\026\131" +
    "\027\136\030\127\031\132\032\143\033\134\034\137\035" +
    "\uffad\036\uffad\037\uffad\040\uffad\042\uffad\043\uffad\045\126" +
    "\051\uffad\060\uffad\001\002\000\070\004\uffb1\005\uffb1\014" +
    "\uffb1\015\uffb1\016\uffb1\017\140\020\uffb1\022\uffb1\023\uffb1" +
    "\024\144\025\135\026\131\027\136\030\127\031\uffb1\032" +
    "\uffb1\033\uffb1\034\uffb1\035\uffb1\036\uffb1\037\uffb1\040\uffb1" +
    "\042\uffb1\043\uffb1\045\126\051\uffb1\060\uffb1\001\002\000" +
    "\070\004\uffb5\005\uffb5\014\uffb5\015\uffb5\016\uffb5\017\140" +
    "\020\uffb5\022\uffb5\023\uffb5\024\uffb5\025\uffb5\026\uffb5\027" +
    "\uffb5\030\uffb5\031\uffb5\032\uffb5\033\uffb5\034\uffb5\035\uffb5" +
    "\036\uffb5\037\uffb5\040\uffb5\042\uffb5\043\uffb5\045\uffb5\051" +
    "\uffb5\060\uffb5\001\002\000\070\004\uffaa\005\uffaa\014\uffaa" +
    "\015\uffaa\016\uffaa\017\140\020\uffaa\022\uffaa\023\uffaa\024" +
    "\144\025\135\026\131\027\136\030\127\031\132\032\143" +
    "\033\134\034\137\035\133\036\142\037\141\040\uffaa\042" +
    "\uffaa\043\uffaa\045\126\051\uffaa\060\uffaa\001\002\000\070" +
    "\004\uffb2\005\uffb2\014\uffb2\015\uffb2\016\uffb2\017\140\020" +
    "\uffb2\022\uffb2\023\uffb2\024\uffb2\025\uffb2\026\uffb2\027\uffb2" +
    "\030\uffb2\031\uffb2\032\uffb2\033\uffb2\034\uffb2\035\uffb2\036" +
    "\uffb2\037\uffb2\040\uffb2\042\uffb2\043\uffb2\045\uffb2\051\uffb2" +
    "\060\uffb2\001\002\000\070\004\uffb4\005\uffb4\014\uffb4\015" +
    "\uffb4\016\uffb4\017\140\020\uffb4\022\uffb4\023\uffb4\024\uffb4" +
    "\025\uffb4\026\uffb4\027\uffb4\030\uffb4\031\uffb4\032\uffb4\033" +
    "\uffb4\034\uffb4\035\uffb4\036\uffb4\037\uffb4\040\uffb4\042\uffb4" +
    "\043\uffb4\045\uffb4\051\uffb4\060\uffb4\001\002\000\010\014" +
    "\uffdc\016\uffdc\022\uffdc\001\002\000\070\004\uff94\005\uff94" +
    "\014\uff94\015\uff94\016\uff94\017\uff94\020\uff94\022\uff94\023" +
    "\uff94\024\uff94\025\uff94\026\uff94\027\uff94\030\uff94\031\uff94" +
    "\032\uff94\033\uff94\034\uff94\035\uff94\036\uff94\037\uff94\040" +
    "\uff94\042\uff94\043\uff94\045\uff94\051\uff94\060\uff94\001\002" +
    "\000\070\004\uff92\005\uff92\014\uff92\015\uff92\016\uff92\017" +
    "\uff92\020\uff92\022\uff92\023\uff92\024\uff92\025\uff92\026\uff92" +
    "\027\uff92\030\uff92\031\uff92\032\uff92\033\uff92\034\uff92\035" +
    "\uff92\036\uff92\037\uff92\040\uff92\042\uff92\043\uff92\045\uff92" +
    "\051\uff92\060\uff92\001\002\000\032\010\106\011\115\012" +
    "\112\013\104\014\171\015\120\025\110\044\103\056\107" +
    "\060\013\061\113\062\105\001\002\000\070\004\uffbd\005" +
    "\uffbd\014\uffbd\015\uffbd\016\uffbd\017\uffbd\020\uffbd\022\uffbd" +
    "\023\uffbd\024\uffbd\025\uffbd\026\uffbd\027\uffbd\030\uffbd\031" +
    "\uffbd\032\uffbd\033\uffbd\034\uffbd\035\uffbd\036\uffbd\037\uffbd" +
    "\040\uffbd\042\uffbd\043\uffbd\045\uffbd\051\uffbd\060\uffbd\001" +
    "\002\000\004\014\173\001\002\000\070\004\uffbe\005\uffbe" +
    "\014\uffbe\015\uffbe\016\uffbe\017\uffbe\020\uffbe\022\uffbe\023" +
    "\uffbe\024\uffbe\025\uffbe\026\uffbe\027\uffbe\030\uffbe\031\uffbe" +
    "\032\uffbe\033\uffbe\034\uffbe\035\uffbe\036\uffbe\037\uffbe\040" +
    "\uffbe\042\uffbe\043\uffbe\045\uffbe\051\uffbe\060\uffbe\001\002" +
    "\000\024\004\uffc7\005\175\015\uffc7\016\uffc7\022\uffc7\042" +
    "\uffc7\043\uffc7\051\uffc7\060\uffc7\001\002\000\014\004\072" +
    "\015\055\042\067\051\056\060\013\001\002\000\024\004" +
    "\uffc6\005\uffc6\015\uffc6\016\uffc6\022\uffc6\042\uffc6\043\uffc6" +
    "\051\uffc6\060\uffc6\001\002\000\070\004\uffb8\005\uffb8\014" +
    "\uffb8\015\uffb8\016\uffb8\017\140\020\uffb8\022\uffb8\023\uffb8" +
    "\024\uffb8\025\uffb8\026\uffb8\027\uffb8\030\uffb8\031\uffb8\032" +
    "\uffb8\033\uffb8\034\uffb8\035\uffb8\036\uffb8\037\uffb8\040\uffb8" +
    "\042\uffb8\043\uffb8\045\uffb8\051\uffb8\060\uffb8\001\002\000" +
    "\070\004\uffbb\005\uffbb\014\uffbb\015\uffbb\016\uffbb\017\uffbb" +
    "\020\uffbb\022\uffbb\023\uffbb\024\uffbb\025\uffbb\026\uffbb\027" +
    "\uffbb\030\uffbb\031\uffbb\032\uffbb\033\uffbb\034\uffbb\035\uffbb" +
    "\036\uffbb\037\uffbb\040\uffbb\042\uffbb\043\uffbb\045\uffbb\051" +
    "\uffbb\060\uffbb\001\002\000\070\004\uffb9\005\uffb9\014\uffb9" +
    "\015\uffb9\016\uffb9\017\140\020\uffb9\022\uffb9\023\uffb9\024" +
    "\uffb9\025\uffb9\026\uffb9\027\uffb9\030\uffb9\031\uffb9\032\uffb9" +
    "\033\uffb9\034\uffb9\035\uffb9\036\uffb9\037\uffb9\040\uffb9\042" +
    "\uffb9\043\uffb9\045\uffb9\051\uffb9\060\uffb9\001\002\000\042" +
    "\014\203\017\140\024\144\025\135\026\131\027\136\030" +
    "\127\031\132\032\143\033\134\034\137\035\133\036\142" +
    "\037\141\040\130\045\126\001\002\000\070\004\uffbf\005" +
    "\uffbf\014\uffbf\015\uffbf\016\uffbf\017\uffbf\020\uffbf\022\uffbf" +
    "\023\uffbf\024\uffbf\025\uffbf\026\uffbf\027\uffbf\030\uffbf\031" +
    "\uffbf\032\uffbf\033\uffbf\034\uffbf\035\uffbf\036\uffbf\037\uffbf" +
    "\040\uffbf\042\uffbf\043\uffbf\045\uffbf\051\uffbf\060\uffbf\001" +
    "\002\000\030\010\106\011\115\012\112\013\104\015\120" +
    "\025\110\044\103\056\107\060\013\061\113\062\105\001" +
    "\002\000\042\014\206\017\140\024\144\025\135\026\131" +
    "\027\136\030\127\031\132\032\143\033\134\034\137\035" +
    "\133\036\142\037\141\040\130\045\126\001\002\000\070" +
    "\004\uffbc\005\uffbc\014\uffbc\015\uffbc\016\uffbc\017\uffbc\020" +
    "\uffbc\022\uffbc\023\uffbc\024\uffbc\025\uffbc\026\uffbc\027\uffbc" +
    "\030\uffbc\031\uffbc\032\uffbc\033\uffbc\034\uffbc\035\uffbc\036" +
    "\uffbc\037\uffbc\040\uffbc\042\uffbc\043\uffbc\045\uffbc\051\uffbc" +
    "\060\uffbc\001\002\000\024\004\uffee\005\uffee\015\uffee\016" +
    "\uffee\022\uffee\042\uffee\043\uffee\051\uffee\060\uffee\001\002" +
    "\000\032\010\106\011\115\012\112\013\104\014\232\015" +
    "\120\025\110\044\103\056\107\060\013\061\113\062\105" +
    "\001\002\000\006\006\031\007\030\001\002\000\024\004" +
    "\uffa8\005\uffa8\015\uffa8\016\uffa8\022\uffa8\042\uffa8\043\uffa8" +
    "\051\uffa8\060\uffa8\001\002\000\032\004\uffd3\005\uffd3\015" +
    "\uffd3\016\uffd3\017\217\022\uffd3\023\uffa1\041\uffa1\042\uffd3" +
    "\043\uffd3\051\uffd3\060\uffd3\001\002\000\024\004\uffd2\005" +
    "\uffd2\015\uffd2\016\uffd2\022\uffd2\042\uffd2\043\uffd2\051\uffd2" +
    "\060\uffd2\001\002\000\032\004\uffca\005\uffca\015\uffca\016" +
    "\uffca\017\230\022\uffca\023\uffca\041\uffca\042\uffca\043\uffca" +
    "\051\uffca\060\uffca\001\002\000\030\004\uffcb\005\uffcb\015" +
    "\uffcb\016\uffcb\022\uffcb\023\uffa2\041\uffa2\042\uffcb\043\uffcb" +
    "\051\uffcb\060\uffcb\001\002\000\032\010\106\011\115\012" +
    "\112\013\104\015\120\020\222\025\110\044\103\056\107" +
    "\060\013\061\113\062\105\001\002\000\032\004\uffcd\005" +
    "\uffcd\015\uffcd\016\uffcd\017\uffcd\022\uffcd\023\uffcd\041\uffcd" +
    "\042\uffcd\043\uffcd\051\uffcd\060\uffcd\001\002\000\032\004" +
    "\uffd0\005\uffd0\015\uffd0\016\uffd0\017\uffd0\022\uffd0\023\uffd0" +
    "\041\uffd0\042\uffd0\043\uffd0\051\uffd0\060\uffd0\001\002\000" +
    "\032\004\uffd1\005\uffd1\015\uffd1\016\uffd1\017\230\022\uffd1" +
    "\023\uffd1\041\uffd1\042\uffd1\043\uffd1\051\uffd1\060\uffd1\001" +
    "\002\000\042\017\140\020\224\024\144\025\135\026\131" +
    "\027\136\030\127\031\132\032\143\033\134\034\137\035" +
    "\133\036\142\037\141\040\130\045\126\001\002\000\032" +
    "\004\uffce\005\uffce\015\uffce\016\uffce\017\217\022\uffce\023" +
    "\uffce\041\uffce\042\uffce\043\uffce\051\uffce\060\uffce\001\002" +
    "\000\032\004\uffcc\005\uffcc\015\uffcc\016\uffcc\017\uffcc\022" +
    "\uffcc\023\uffcc\041\uffcc\042\uffcc\043\uffcc\051\uffcc\060\uffcc" +
    "\001\002\000\032\004\uffcb\005\uffcb\015\uffcb\016\uffcb\017" +
    "\uffcb\022\uffcb\023\uffcb\041\uffcb\042\uffcb\043\uffcb\051\uffcb" +
    "\060\uffcb\001\002\000\032\004\uffcf\005\uffcf\015\uffcf\016" +
    "\uffcf\017\uffcf\022\uffcf\023\uffcf\041\uffcf\042\uffcf\043\uffcf" +
    "\051\uffcf\060\uffcf\001\002\000\004\020\222\001\002\000" +
    "\032\004\uffc9\005\uffc9\015\uffc9\016\uffc9\017\uffc9\022\uffc9" +
    "\023\uffc9\041\uffc9\042\uffc9\043\uffc9\051\uffc9\060\uffc9\001" +
    "\002\000\026\004\uffe6\005\uffe6\015\uffe6\016\uffe6\017\240" +
    "\022\uffe6\042\uffe6\043\uffe6\051\uffe6\060\uffe6\001\002\000" +
    "\004\014\234\001\002\000\026\004\uffe7\005\uffe7\015\uffe7" +
    "\016\uffe7\017\235\022\uffe7\042\uffe7\043\uffe7\051\uffe7\060" +
    "\uffe7\001\002\000\030\010\106\011\115\012\112\013\104" +
    "\015\120\025\110\044\103\056\107\060\013\061\113\062" +
    "\105\001\002\000\042\017\140\020\237\024\144\025\135" +
    "\026\131\027\136\030\127\031\132\032\143\033\134\034" +
    "\137\035\133\036\142\037\141\040\130\045\126\001\002" +
    "\000\006\017\uff9c\041\uff9c\001\002\000\030\010\106\011" +
    "\115\012\112\013\104\015\120\025\110\044\103\056\107" +
    "\060\013\061\113\062\105\001\002\000\042\017\140\020" +
    "\242\024\144\025\135\026\131\027\136\030\127\031\132" +
    "\032\143\033\134\034\137\035\133\036\142\037\141\040" +
    "\130\045\126\001\002\000\006\017\uff9b\041\uff9b\001\002" +
    "\000\052\004\072\015\055\017\140\024\144\025\135\026" +
    "\131\027\136\030\127\031\132\032\143\033\134\034\137" +
    "\035\133\036\142\037\141\040\130\042\067\045\126\051" +
    "\056\060\013\001\002\000\024\004\uffc8\005\uffc8\015\uffc8" +
    "\016\uffc8\022\uffc8\042\uffc8\043\uffc8\051\uffc8\060\uffc8\001" +
    "\002\000\030\010\106\011\115\012\112\013\104\015\120" +
    "\025\110\044\103\056\107\060\013\061\113\062\105\001" +
    "\002\000\030\010\106\011\115\012\112\013\104\015\120" +
    "\025\110\044\103\056\107\060\013\061\113\062\105\001" +
    "\002\000\062\004\uffa0\005\uffa0\015\uffa0\016\uffa0\017\140" +
    "\022\uffa0\024\144\025\135\026\131\027\136\030\127\031" +
    "\132\032\143\033\134\034\137\035\133\036\142\037\141" +
    "\040\130\042\uffa0\043\uffa0\045\126\051\uffa0\060\uffa0\001" +
    "\002\000\042\017\140\020\251\024\144\025\135\026\131" +
    "\027\136\030\127\031\132\032\143\033\134\034\137\035" +
    "\133\036\142\037\141\040\130\045\126\001\002\000\006" +
    "\017\uff9d\041\uff9d\001\002\000\004\016\uffe1\001\002\000" +
    "\006\016\uffe2\022\254\001\002\000\004\016\uffe0\001\002" +
    "\000\006\051\260\060\013\001\002\000\030\010\106\011" +
    "\115\012\112\013\104\015\120\025\110\044\103\056\107" +
    "\060\013\061\113\062\105\001\002\000\062\004\uff9f\005" +
    "\uff9f\015\uff9f\016\uff9f\017\140\022\uff9f\024\144\025\135" +
    "\026\131\027\136\030\127\031\132\032\143\033\134\034" +
    "\137\035\133\036\142\037\141\040\130\042\uff9f\043\uff9f" +
    "\045\126\051\uff9f\060\uff9f\001\002\000\006\023\uffa4\041" +
    "\uffa4\001\002\000\006\017\263\021\264\001\002\000\006" +
    "\023\uffa5\041\uffa5\001\002\000\030\010\106\011\115\012" +
    "\112\013\104\015\120\025\110\044\103\056\107\060\013" +
    "\061\113\062\105\001\002\000\006\006\031\007\030\001" +
    "\002\000\010\017\230\023\uffa7\041\uffa7\001\002\000\006" +
    "\023\uffa6\041\uffa6\001\002\000\026\002\uffc5\004\uffc5\005" +
    "\uffc5\015\uffc5\016\uffc5\022\uffc5\042\uffc5\043\uffc5\051\uffc5" +
    "\060\uffc5\001\002\000\004\016\271\001\002\000\026\002" +
    "\uffc4\004\uffc4\005\uffc4\015\uffc4\016\uffc4\022\uffc4\042\uffc4" +
    "\043\uffc4\051\uffc4\060\uffc4\001\002\000\006\002\uffe9\060" +
    "\uffe9\001\002\000\010\022\274\046\ufff7\060\ufff7\001\002" +
    "\000\006\046\ufff6\060\ufff6\001\002\000\004\002\001\001" +
    "\002" });

  /** Access to parse-action table. */
  @Override
  public short[][] action_table() {return _action_table;}

  /** {@code reduce_goto} table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\273\000\016\003\003\004\006\005\010\022\005\023" +
    "\011\044\007\001\001\000\002\001\001\000\004\044\272" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\014" +
    "\051\001\001\000\010\004\050\022\047\044\007\001\001" +
    "\000\006\004\046\044\007\001\001\000\002\001\001\000" +
    "\006\002\015\044\014\001\001\000\004\014\044\001\001" +
    "\000\004\044\016\001\001\000\004\014\017\001\001\000" +
    "\004\021\036\001\001\000\006\013\021\044\022\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\006\015\025\017\026\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\013" +
    "\034\044\022\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\010\015\025\017\041\020\040\001\001\000\002\001\001" +
    "\000\002\001\001\000\010\015\025\017\041\020\043\001" +
    "\001\000\002\001\001\000\004\021\045\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\021\052\041\053\001\001\000\004\041\271" +
    "\001\001\000\002\001\001\000\030\024\061\025\062\026" +
    "\073\027\056\030\074\036\057\037\072\040\060\041\067" +
    "\043\065\044\070\001\001\000\002\001\001\000\004\030" +
    "\267\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\016\006\252\031\123\034" +
    "\101\035\116\042\110\044\115\001\001\000\002\001\001" +
    "\000\002\001\001\000\014\031\242\034\101\035\116\042" +
    "\110\044\115\001\001\000\002\001\001\000\004\007\206" +
    "\001\001\000\014\031\113\034\101\035\116\042\110\044" +
    "\115\001\001\000\002\001\001\000\026\024\061\025\062" +
    "\026\073\027\076\036\057\037\072\040\060\041\067\043" +
    "\065\044\070\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\026\024\061\025\062\026\073\027" +
    "\100\036\057\037\072\040\060\041\067\043\065\044\070" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\014\031\201\034\101\035\116\042\110\044\115" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\014\031\200\034\101\035\116\042\110\044\115" +
    "\001\001\000\002\001\001\000\014\031\176\034\101\035" +
    "\116\042\110\044\115\001\001\000\002\001\001\000\024" +
    "\024\061\025\062\026\173\036\057\037\072\040\060\041" +
    "\067\043\065\044\070\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\016\006\122\031\123\034" +
    "\101\035\116\042\110\044\115\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\016\006\164\031\123\034\101\035\116\042\110\044\115" +
    "\001\001\000\014\031\163\034\101\035\116\042\110\044" +
    "\115\001\001\000\014\031\162\034\101\035\116\042\110" +
    "\044\115\001\001\000\014\031\161\034\101\035\116\042" +
    "\110\044\115\001\001\000\014\031\160\034\101\035\116" +
    "\042\110\044\115\001\001\000\014\031\157\034\101\035" +
    "\116\042\110\044\115\001\001\000\014\031\156\034\101" +
    "\035\116\042\110\044\115\001\001\000\014\031\155\034" +
    "\101\035\116\042\110\044\115\001\001\000\014\031\154" +
    "\034\101\035\116\042\110\044\115\001\001\000\014\031" +
    "\153\034\101\035\116\042\110\044\115\001\001\000\014" +
    "\031\152\034\101\035\116\042\110\044\115\001\001\000" +
    "\014\031\150\034\101\035\116\042\110\044\115\001\001" +
    "\000\014\031\147\034\101\035\116\042\110\044\115\001" +
    "\001\000\014\031\146\034\101\035\116\042\110\044\115" +
    "\001\001\000\014\031\145\034\101\035\116\042\110\044" +
    "\115\001\001\000\014\031\144\034\101\035\116\042\110" +
    "\044\115\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\016\006\171\031\123\034\101\035\116\042" +
    "\110\044\115\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\024\024\061\025" +
    "\062\026\175\036\057\037\072\040\060\041\067\043\065" +
    "\044\070\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\014\031\204\034\101\035\116\042\110\044" +
    "\115\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\016\006\232\031\123\034\101\035\116\042" +
    "\110\044\115\001\001\000\006\015\212\016\211\001\001" +
    "\000\002\001\001\000\014\010\214\011\215\012\213\032" +
    "\217\033\220\001\001\000\002\001\001\000\006\011\230" +
    "\033\220\001\001\000\002\001\001\000\014\031\222\034" +
    "\101\035\116\042\110\044\115\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\011\226\033\220\001\001\000" +
    "\002\001\001\000\014\010\214\011\225\012\224\032\217" +
    "\033\220\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\014\031" +
    "\235\034\101\035\116\042\110\044\115\001\001\000\002" +
    "\001\001\000\002\001\001\000\014\031\240\034\101\035" +
    "\116\042\110\044\115\001\001\000\002\001\001\000\002" +
    "\001\001\000\024\024\061\025\062\026\243\036\057\037" +
    "\072\040\060\041\067\043\065\044\070\001\001\000\002" +
    "\001\001\000\014\031\247\034\101\035\116\042\110\044" +
    "\115\001\001\000\014\031\246\034\101\035\116\042\110" +
    "\044\115\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\044\260\001\001\000\014\031\256\034" +
    "\101\035\116\042\110\044\115\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\010\261\032\217\001\001\000" +
    "\002\001\001\000\014\031\222\034\101\035\116\042\110" +
    "\044\115\001\001\000\004\015\264\001\001\000\006\011" +
    "\265\033\220\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001" });

  /** Access to {@code reduce_goto} table. */
  @Override
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  @Override
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  @Override
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack<java_cup.runtime.Symbol> stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  @Override
  public int start_state() {return 0;}
  /** Indicates start production. */
  @Override
  public int start_production() {return 0;}

  /** {@code EOF} Symbol index. */
  @Override
  public int EOF_sym() {return 0;}

  /** {@code error} Symbol index. */
  @Override
  public int error_sym() {return 1;}




public void syntax_error(Symbol cur_token){
      return;
}

public void unrecovered_syntax_error(Symbol cur_token) throws ParserException {
      Token token = (Token) cur_token;
      String message = "Unexpected token " + token.getAttribute();

      report_fatal_error(message, token);

}

public void report_fatal_error(String message, Token token) throws ParserException {
      done_parsing();
      throw new ParserException(message, token);
}



/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {
    private final parser parser;

    /** Constructor */
    CUP$parser$actions(parser parser) {
        this.parser = parser;
    }

    /** Method with the actual generated action code for actions 0 to 112. */
    public final java_cup.runtime.Symbol CUP$parser$do_action_part00000000(
            int                        CUP$parser$act_num,
            java_cup.runtime.lr_parser CUP$parser$parser,
            java.util.Stack<java_cup.runtime.Symbol> CUP$parser$stack,
            int                        CUP$parser$top)
            throws java.lang.Exception {
            /* Symbol object for return from actions */
            java_cup.runtime.Symbol CUP$parser$result;

        /* select the action based on the action number */
        switch (CUP$parser$act_num) {
        /*. . . . . . . . . . . . . . . . . . . .*/
        case 0: // $START ::= parse_tree EOF 
            {
                Object RESULT = null;
                int start_valleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int start_valright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Node start_val = CUP$parser$stack.elementAt(CUP$parser$top-1).<Node> value();
                RESULT = start_val;
                CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            /* ACCEPT */
            CUP$parser$parser.done_parsing();
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 1: // parse_tree ::= program 
            {
                Node RESULT = null;
                int pleft = CUP$parser$stack.peek().left;
                int pright = CUP$parser$stack.peek().right;
                Program p = CUP$parser$stack.peek().<Program> value();
                 RESULT = p; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("parse_tree",1, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 2: // parse_tree ::= IXI interface 
            {
                Node RESULT = null;
                int ileft = CUP$parser$stack.peek().left;
                int iright = CUP$parser$stack.peek().right;
                Interface i = CUP$parser$stack.peek().<Interface> value();
                 RESULT = i; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("parse_tree",1, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 3: // interface ::= id method_params method_types 
            {
                Interface RESULT = null;
                int idleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int idright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Identifier id = CUP$parser$stack.elementAt(CUP$parser$top-2).<Identifier> value();
                int paramsleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int paramsright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                LinkedList<Declaration> params = CUP$parser$stack.elementAt(CUP$parser$top-1).<LinkedList<Declaration>> value();
                int tsleft = CUP$parser$stack.peek().left;
                int tsright = CUP$parser$stack.peek().right;
                LinkedList<Type> ts = CUP$parser$stack.peek().<LinkedList<Type>> value();
                 RESULT = new Interface(id, params, ts); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("interface",0, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 4: // interface ::= id method_params 
            {
                Interface RESULT = null;
                int idleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int idright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Identifier id = CUP$parser$stack.elementAt(CUP$parser$top-1).<Identifier> value();
                int paramsleft = CUP$parser$stack.peek().left;
                int paramsright = CUP$parser$stack.peek().right;
                LinkedList<Declaration> params = CUP$parser$stack.peek().<LinkedList<Declaration>> value();
                 RESULT = new Interface(id, params, new LinkedList<Type>()); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("interface",0, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 5: // interface ::= interface id method_params method_types 
            {
                Interface RESULT = null;
                int ileft = CUP$parser$stack.elementAt(CUP$parser$top-3).left;
                int iright = CUP$parser$stack.elementAt(CUP$parser$top-3).right;
                Interface i = CUP$parser$stack.elementAt(CUP$parser$top-3).<Interface> value();
                int idleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int idright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Identifier id = CUP$parser$stack.elementAt(CUP$parser$top-2).<Identifier> value();
                int paramsleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int paramsright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                LinkedList<Declaration> params = CUP$parser$stack.elementAt(CUP$parser$top-1).<LinkedList<Declaration>> value();
                int tsleft = CUP$parser$stack.peek().left;
                int tsright = CUP$parser$stack.peek().right;
                LinkedList<Type> ts = CUP$parser$stack.peek().<LinkedList<Type>> value();
                 i.appendMethodDeclaration(new MethodDeclaration(id, params, ts)); RESULT = i; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("interface",0, CUP$parser$stack.elementAt(CUP$parser$top-3), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 6: // interface ::= interface id method_params 
            {
                Interface RESULT = null;
                int ileft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int iright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Interface i = CUP$parser$stack.elementAt(CUP$parser$top-2).<Interface> value();
                int idleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int idright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Identifier id = CUP$parser$stack.elementAt(CUP$parser$top-1).<Identifier> value();
                int paramsleft = CUP$parser$stack.peek().left;
                int paramsright = CUP$parser$stack.peek().right;
                LinkedList<Declaration> params = CUP$parser$stack.peek().<LinkedList<Declaration>> value();
                 i.appendMethodDeclaration(new MethodDeclaration(id, params, new LinkedList<Type>())); RESULT = i; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("interface",0, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 7: // program ::= method_def 
            {
                Program RESULT = null;
                int mdleft = CUP$parser$stack.peek().left;
                int mdright = CUP$parser$stack.peek().right;
                MethodDef md = CUP$parser$stack.peek().<MethodDef> value();
                 RESULT = new Program(md); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("program",17, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 8: // program ::= use_list method_def 
            {
                Program RESULT = null;
                int uleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int uright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                LinkedList<Use> u = CUP$parser$stack.elementAt(CUP$parser$top-1).<LinkedList<Use>> value();
                int mdleft = CUP$parser$stack.peek().left;
                int mdright = CUP$parser$stack.peek().right;
                MethodDef md = CUP$parser$stack.peek().<MethodDef> value();
                 RESULT = new Program(u, md); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("program",17, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 9: // program ::= program method_def 
            {
                Program RESULT = null;
                int pleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int pright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Program p = CUP$parser$stack.elementAt(CUP$parser$top-1).<Program> value();
                int mdleft = CUP$parser$stack.peek().left;
                int mdright = CUP$parser$stack.peek().right;
                MethodDef md = CUP$parser$stack.peek().<MethodDef> value();
                 p.appendMethod(md); RESULT = p; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("program",17, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 10: // use ::= USE id 
            {
                Use RESULT = null;
                int uleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int uright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Object u = CUP$parser$stack.elementAt(CUP$parser$top-1).<Object> value();
                int idleft = CUP$parser$stack.peek().left;
                int idright = CUP$parser$stack.peek().right;
                Identifier id = CUP$parser$stack.peek().<Identifier> value();
                 RESULT = (Use) new Use(id).setLine(uright).setColumn(uleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("use",16, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 11: // use ::= USE id SEMICOLON 
            {
                Use RESULT = null;
                int uleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int uright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Object u = CUP$parser$stack.elementAt(CUP$parser$top-2).<Object> value();
                int idleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int idright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Identifier id = CUP$parser$stack.elementAt(CUP$parser$top-1).<Identifier> value();
                 RESULT = (Use) new Use(id).setLine(uright).setColumn(uleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("use",16, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 12: // use_list ::= use 
            {
                LinkedList<Use> RESULT = null;
                int uleft = CUP$parser$stack.peek().left;
                int uright = CUP$parser$stack.peek().right;
                Use u = CUP$parser$stack.peek().<Use> value();
                 LinkedList<Use> lst = new LinkedList<Use>(); lst.add(u); RESULT = lst; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("use_list",3, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 13: // use_list ::= use_list use 
            {
                LinkedList<Use> RESULT = null;
                int usleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int usright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                LinkedList<Use> us = CUP$parser$stack.elementAt(CUP$parser$top-1).<LinkedList<Use>> value();
                int uleft = CUP$parser$stack.peek().left;
                int uright = CUP$parser$stack.peek().right;
                Use u = CUP$parser$stack.peek().<Use> value();
                 us.add(u); RESULT = us; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("use_list",3, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 14: // stmt ::= assignment 
            {
                Stmt RESULT = null;
                int aleft = CUP$parser$stack.peek().left;
                int aright = CUP$parser$stack.peek().right;
                Assignment a = CUP$parser$stack.peek().<Assignment> value();
                 RESULT = a; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("stmt",20, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 15: // stmt ::= block 
            {
                Stmt RESULT = null;
                int bleft = CUP$parser$stack.peek().left;
                int bright = CUP$parser$stack.peek().right;
                Block b = CUP$parser$stack.peek().<Block> value();
                 RESULT = b; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("stmt",20, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 16: // stmt ::= declaration 
            {
                Stmt RESULT = null;
                int dleft = CUP$parser$stack.peek().left;
                int dright = CUP$parser$stack.peek().right;
                Declaration d = CUP$parser$stack.peek().<Declaration> value();
                 RESULT = d; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("stmt",20, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 17: // stmt ::= if 
            {
                Stmt RESULT = null;
                int ileft = CUP$parser$stack.peek().left;
                int iright = CUP$parser$stack.peek().right;
                If i = CUP$parser$stack.peek().<If> value();
                 RESULT = i; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("stmt",20, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 18: // stmt ::= while 
            {
                Stmt RESULT = null;
                int wleft = CUP$parser$stack.peek().left;
                int wright = CUP$parser$stack.peek().right;
                While w = CUP$parser$stack.peek().<While> value();
                 RESULT = w; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("stmt",20, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 19: // stmt ::= id procedure_args 
            {
                Stmt RESULT = null;
                int idleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int idright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Identifier id = CUP$parser$stack.elementAt(CUP$parser$top-1).<Identifier> value();
                int argsleft = CUP$parser$stack.peek().left;
                int argsright = CUP$parser$stack.peek().right;
                LinkedList<Expr> args = CUP$parser$stack.peek().<LinkedList<Expr>> value();
                 RESULT = new ProcedureCall(id, args); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("stmt",20, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 20: // stmts ::= stmt SEMICOLON stmts 
            {
                LinkedList<Stmt> RESULT = null;
                int sleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int sright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Stmt s = CUP$parser$stack.elementAt(CUP$parser$top-2).<Stmt> value();
                int lstleft = CUP$parser$stack.peek().left;
                int lstright = CUP$parser$stack.peek().right;
                LinkedList<Stmt> lst = CUP$parser$stack.peek().<LinkedList<Stmt>> value();
                 lst.addFirst(s); RESULT = lst; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("stmts",21, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 21: // stmts ::= stmt stmts 
            {
                LinkedList<Stmt> RESULT = null;
                int sleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int sright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Stmt s = CUP$parser$stack.elementAt(CUP$parser$top-1).<Stmt> value();
                int lstleft = CUP$parser$stack.peek().left;
                int lstright = CUP$parser$stack.peek().right;
                LinkedList<Stmt> lst = CUP$parser$stack.peek().<LinkedList<Stmt>> value();
                 lst.addFirst(s); RESULT =  lst; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("stmts",21, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 22: // stmts ::= stmt 
            {
                LinkedList<Stmt> RESULT = null;
                int sleft = CUP$parser$stack.peek().left;
                int sright = CUP$parser$stack.peek().right;
                Stmt s = CUP$parser$stack.peek().<Stmt> value();
                 LinkedList<Stmt> lst = new LinkedList<Stmt>(); lst.add(s); RESULT = lst; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("stmts",21, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 23: // stmts ::= stmt SEMICOLON 
            {
                LinkedList<Stmt> RESULT = null;
                int sleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int sright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Stmt s = CUP$parser$stack.elementAt(CUP$parser$top-1).<Stmt> value();
                 LinkedList<Stmt> lst = new LinkedList<Stmt>(); lst.add(s); RESULT = lst; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("stmts",21, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 24: // method_def ::= id method_params method_types block 
            {
                MethodDef RESULT = null;
                int idleft = CUP$parser$stack.elementAt(CUP$parser$top-3).left;
                int idright = CUP$parser$stack.elementAt(CUP$parser$top-3).right;
                Identifier id = CUP$parser$stack.elementAt(CUP$parser$top-3).<Identifier> value();
                int paramleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int paramright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                LinkedList<Declaration> param = CUP$parser$stack.elementAt(CUP$parser$top-2).<LinkedList<Declaration>> value();
                int typeleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int typeright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                LinkedList<Type> type = CUP$parser$stack.elementAt(CUP$parser$top-1).<LinkedList<Type>> value();
                int blockleft = CUP$parser$stack.peek().left;
                int blockright = CUP$parser$stack.peek().right;
                Block block = CUP$parser$stack.peek().<Block> value();
                 RESULT = new MethodDef(id, param, type, block); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("method_def",2, CUP$parser$stack.elementAt(CUP$parser$top-3), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 25: // method_def ::= id method_params block 
            {
                MethodDef RESULT = null;
                int idleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int idright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Identifier id = CUP$parser$stack.elementAt(CUP$parser$top-2).<Identifier> value();
                int paramleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int paramright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                LinkedList<Declaration> param = CUP$parser$stack.elementAt(CUP$parser$top-1).<LinkedList<Declaration>> value();
                int blockleft = CUP$parser$stack.peek().left;
                int blockright = CUP$parser$stack.peek().right;
                Block block = CUP$parser$stack.peek().<Block> value();
                 RESULT = new MethodDef(id, param, new LinkedList<Type>(), block); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("method_def",2, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 26: // procedure_args ::= LPAREN arg RPAREN 
            {
                LinkedList<Expr> RESULT = null;
                int argleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int argright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                LinkedList<Expr> arg = CUP$parser$stack.elementAt(CUP$parser$top-1).<LinkedList<Expr>> value();
                 RESULT = arg; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_args",5, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 27: // procedure_args ::= LPAREN RPAREN 
            {
                LinkedList<Expr> RESULT = null;
                 RESULT = new LinkedList<Expr>();  
                CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_args",5, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 28: // method_params ::= LPAREN param RPAREN 
            {
                LinkedList<Declaration> RESULT = null;
                int paramleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int paramright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                LinkedList<Declaration> param = CUP$parser$stack.elementAt(CUP$parser$top-1).<LinkedList<Declaration>> value();
                 RESULT = param; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("method_params",10, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 29: // method_params ::= LPAREN RPAREN 
            {
                LinkedList<Declaration> RESULT = null;
                 RESULT = new LinkedList<Declaration>(); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("method_params",10, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 30: // return ::= RETURN 
            {
                Return RESULT = null;
                int rleft = CUP$parser$stack.peek().left;
                int rright = CUP$parser$stack.peek().right;
                Object r = CUP$parser$stack.peek().<Object> value();
                 RESULT = (Return) new Return().setLine(rright).setColumn(rleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("return",22, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 31: // return ::= RETURN arg 
            {
                Return RESULT = null;
                int rleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int rright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Object r = CUP$parser$stack.elementAt(CUP$parser$top-1).<Object> value();
                int argleft = CUP$parser$stack.peek().left;
                int argright = CUP$parser$stack.peek().right;
                LinkedList<Expr> arg = CUP$parser$stack.peek().<LinkedList<Expr>> value();
                 RESULT = (Return) new Return(arg).setLine(rright).setColumn(rleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("return",22, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 32: // return ::= RETURN SEMICOLON 
            {
                Return RESULT = null;
                int rleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int rright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Object r = CUP$parser$stack.elementAt(CUP$parser$top-1).<Object> value();
                 RESULT = (Return) new Return().setLine(rright).setColumn(rleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("return",22, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 33: // return ::= RETURN arg SEMICOLON 
            {
                Return RESULT = null;
                int rleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int rright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Object r = CUP$parser$stack.elementAt(CUP$parser$top-2).<Object> value();
                int argleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int argright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                LinkedList<Expr> arg = CUP$parser$stack.elementAt(CUP$parser$top-1).<LinkedList<Expr>> value();
                 RESULT = (Return) new Return(arg).setLine(rright).setColumn(rleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("return",22, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 34: // param ::= id COLON assign_type 
            {
                LinkedList<Declaration> RESULT = null;
                int idleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int idright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Identifier id = CUP$parser$stack.elementAt(CUP$parser$top-2).<Identifier> value();
                int tleft = CUP$parser$stack.peek().left;
                int tright = CUP$parser$stack.peek().right;
                Type t = CUP$parser$stack.peek().<Type> value();
                 LinkedList<Declaration> lst = new LinkedList<Declaration>(); lst.add(new Declaration(id, t)); RESULT = lst; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("param",9, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 35: // param ::= id COLON assign_type COMMA param 
            {
                LinkedList<Declaration> RESULT = null;
                int idleft = CUP$parser$stack.elementAt(CUP$parser$top-4).left;
                int idright = CUP$parser$stack.elementAt(CUP$parser$top-4).right;
                Identifier id = CUP$parser$stack.elementAt(CUP$parser$top-4).<Identifier> value();
                int tleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int tright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Type t = CUP$parser$stack.elementAt(CUP$parser$top-2).<Type> value();
                int pleft = CUP$parser$stack.peek().left;
                int pright = CUP$parser$stack.peek().right;
                LinkedList<Declaration> p = CUP$parser$stack.peek().<LinkedList<Declaration>> value();
                 p.addFirst(new Declaration(id, t)); RESULT = p; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("param",9, CUP$parser$stack.elementAt(CUP$parser$top-4), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 36: // arg ::= expr 
            {
                LinkedList<Expr> RESULT = null;
                int eleft = CUP$parser$stack.peek().left;
                int eright = CUP$parser$stack.peek().right;
                Expr e = CUP$parser$stack.peek().<Expr> value();
                 LinkedList<Expr> lst = new LinkedList<Expr>(); lst.add(e); RESULT = lst; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("arg",4, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 37: // arg ::= expr COMMA arg 
            {
                LinkedList<Expr> RESULT = null;
                int eleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int eright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Expr e = CUP$parser$stack.elementAt(CUP$parser$top-2).<Expr> value();
                int lstleft = CUP$parser$stack.peek().left;
                int lstright = CUP$parser$stack.peek().right;
                LinkedList<Expr> lst = CUP$parser$stack.peek().<LinkedList<Expr>> value();
                 lst.addFirst(e); RESULT = lst; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("arg",4, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 38: // arg ::= expr COMMA 
            {
                LinkedList<Expr> RESULT = null;
                int eleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int eright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Expr e = CUP$parser$stack.elementAt(CUP$parser$top-1).<Expr> value();
                 LinkedList<Expr> lst = new LinkedList<Expr>(); lst.add(e); RESULT = lst; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("arg",4, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 39: // method_types ::= COLON assign_type_list 
            {
                LinkedList<Type> RESULT = null;
                int aleft = CUP$parser$stack.peek().left;
                int aright = CUP$parser$stack.peek().right;
                LinkedList<Type> a = CUP$parser$stack.peek().<LinkedList<Type>> value();
                 RESULT = a; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("method_types",15, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 40: // assign_type_list ::= assign_type 
            {
                LinkedList<Type> RESULT = null;
                int aleft = CUP$parser$stack.peek().left;
                int aright = CUP$parser$stack.peek().right;
                Type a = CUP$parser$stack.peek().<Type> value();
                 LinkedList<Type> lst = new LinkedList<Type>(); lst.add(a); RESULT = lst; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("assign_type_list",14, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 41: // assign_type_list ::= assign_type COMMA assign_type_list 
            {
                LinkedList<Type> RESULT = null;
                int aleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int aright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Type a = CUP$parser$stack.elementAt(CUP$parser$top-2).<Type> value();
                int lstleft = CUP$parser$stack.peek().left;
                int lstright = CUP$parser$stack.peek().right;
                LinkedList<Type> lst = CUP$parser$stack.peek().<LinkedList<Type>> value();
                 lst.addFirst(a); RESULT = lst; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("assign_type_list",14, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 42: // type ::= INT_TYPE 
            {
                Type RESULT = null;
                int tleft = CUP$parser$stack.peek().left;
                int tright = CUP$parser$stack.peek().right;
                Object t = CUP$parser$stack.peek().<Object> value();
                 RESULT = (Type) new IntType().setLine(tright).setColumn(tleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("type",11, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 43: // type ::= BOOL_TYPE 
            {
                Type RESULT = null;
                int tleft = CUP$parser$stack.peek().left;
                int tright = CUP$parser$stack.peek().right;
                Object t = CUP$parser$stack.peek().<Object> value();
                 RESULT = (Type) new BoolType().setLine(tright).setColumn(tleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("type",11, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 44: // assign_type ::= type 
            {
                Type RESULT = null;
                int tleft = CUP$parser$stack.peek().left;
                int tright = CUP$parser$stack.peek().right;
                Type t = CUP$parser$stack.peek().<Type> value();
                 RESULT = t; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("assign_type",13, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 45: // assign_type ::= assign_type LBRACK RBRACK 
            {
                Type RESULT = null;
                int tleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int tright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Type t = CUP$parser$stack.elementAt(CUP$parser$top-2).<Type> value();
                 RESULT = new ArrayType(t, null); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("assign_type",13, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 46: // decl_type ::= type 
            {
                Type RESULT = null;
                int tleft = CUP$parser$stack.peek().left;
                int tright = CUP$parser$stack.peek().right;
                Type t = CUP$parser$stack.peek().<Type> value();
                 RESULT = t; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_type",12, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 47: // decl_type ::= type indices 
            {
                Type RESULT = null;
                int tleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int tright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Type t = CUP$parser$stack.elementAt(CUP$parser$top-1).<Type> value();
                int ileft = CUP$parser$stack.peek().left;
                int iright = CUP$parser$stack.peek().right;
                LinkedList<Expr> i = CUP$parser$stack.peek().<LinkedList<Expr>> value();
                 RESULT = ArrayType.fromList(t, i); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_type",12, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 48: // emptyindex ::= LBRACK RBRACK 
            {
                Expr RESULT = null;
                 RESULT = null; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("emptyindex",25, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 49: // indices_empty ::= emptyindex 
            {
                LinkedList<Expr> RESULT = null;
                 LinkedList<Expr> lst = new LinkedList<Expr>(); lst.add(null); RESULT = lst;
                CUP$parser$result = parser.getSymbolFactory().newSymbol("indices_empty",7, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 50: // indices_empty ::= LBRACK RBRACK indices_empty 
            {
                LinkedList<Expr> RESULT = null;
                int lstleft = CUP$parser$stack.peek().left;
                int lstright = CUP$parser$stack.peek().right;
                LinkedList<Expr> lst = CUP$parser$stack.peek().<LinkedList<Expr>> value();
                 lst.add(null); RESULT = lst; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("indices_empty",7, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 51: // index ::= LBRACK expr RBRACK 
            {
                Expr RESULT = null;
                int eleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int eright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Expr e = CUP$parser$stack.elementAt(CUP$parser$top-1).<Expr> value();
                 RESULT = e; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("index",24, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 52: // indices_full ::= index 
            {
                LinkedList<Expr> RESULT = null;
                int ileft = CUP$parser$stack.peek().left;
                int iright = CUP$parser$stack.peek().right;
                Expr i = CUP$parser$stack.peek().<Expr> value();
                 LinkedList<Expr> lst = new LinkedList<Expr>(); lst.add(i); RESULT = lst; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("indices_full",6, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 53: // indices_full ::= LBRACK expr RBRACK indices 
            {
                LinkedList<Expr> RESULT = null;
                int eleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int eright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Expr e = CUP$parser$stack.elementAt(CUP$parser$top-2).<Expr> value();
                int lstleft = CUP$parser$stack.peek().left;
                int lstright = CUP$parser$stack.peek().right;
                LinkedList<Expr> lst = CUP$parser$stack.peek().<LinkedList<Expr>> value();
                 lst.add(e); RESULT = lst; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("indices_full",6, CUP$parser$stack.elementAt(CUP$parser$top-3), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 54: // indices ::= indices_empty 
            {
                LinkedList<Expr> RESULT = null;
                int lstleft = CUP$parser$stack.peek().left;
                int lstright = CUP$parser$stack.peek().right;
                LinkedList<Expr> lst = CUP$parser$stack.peek().<LinkedList<Expr>> value();
                 RESULT = lst; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("indices",8, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 55: // indices ::= indices_full 
            {
                LinkedList<Expr> RESULT = null;
                int lstleft = CUP$parser$stack.peek().left;
                int lstright = CUP$parser$stack.peek().right;
                LinkedList<Expr> lst = CUP$parser$stack.peek().<LinkedList<Expr>> value();
                 RESULT = lst; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("indices",8, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 56: // indices ::= indices_full indices_empty 
            {
                LinkedList<Expr> RESULT = null;
                int lst1left = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int lst1right = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                LinkedList<Expr> lst1 = CUP$parser$stack.elementAt(CUP$parser$top-1).<LinkedList<Expr>> value();
                int lst2left = CUP$parser$stack.peek().left;
                int lst2right = CUP$parser$stack.peek().right;
                LinkedList<Expr> lst2 = CUP$parser$stack.peek().<LinkedList<Expr>> value();
                 for(Expr e: lst2) lst1.add(null); RESULT = lst1; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("indices",8, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 57: // while ::= WHILE expr stmt 
            {
                While RESULT = null;
                int wleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int wright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Object w = CUP$parser$stack.elementAt(CUP$parser$top-2).<Object> value();
                int eleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int eright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Expr e = CUP$parser$stack.elementAt(CUP$parser$top-1).<Expr> value();
                int sleft = CUP$parser$stack.peek().left;
                int sright = CUP$parser$stack.peek().right;
                Stmt s = CUP$parser$stack.peek().<Stmt> value();
                 RESULT = (While) new While(e, s).setLine(wright).setColumn(wleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("while",30, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 58: // if ::= IF expr stmt 
            {
                If RESULT = null;
                int ileft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int iright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Object i = CUP$parser$stack.elementAt(CUP$parser$top-2).<Object> value();
                int eleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int eright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Expr e = CUP$parser$stack.elementAt(CUP$parser$top-1).<Expr> value();
                int s1left = CUP$parser$stack.peek().left;
                int s1right = CUP$parser$stack.peek().right;
                Stmt s1 = CUP$parser$stack.peek().<Stmt> value();
                 RESULT = (If) new If(e, s1, null).setLine(iright).setColumn(ileft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("if",29, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 59: // if ::= IF expr stmt ELSE stmt 
            {
                If RESULT = null;
                int ileft = CUP$parser$stack.elementAt(CUP$parser$top-4).left;
                int iright = CUP$parser$stack.elementAt(CUP$parser$top-4).right;
                Object i = CUP$parser$stack.elementAt(CUP$parser$top-4).<Object> value();
                int eleft = CUP$parser$stack.elementAt(CUP$parser$top-3).left;
                int eright = CUP$parser$stack.elementAt(CUP$parser$top-3).right;
                Expr e = CUP$parser$stack.elementAt(CUP$parser$top-3).<Expr> value();
                int s1left = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int s1right = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Stmt s1 = CUP$parser$stack.elementAt(CUP$parser$top-2).<Stmt> value();
                int s2left = CUP$parser$stack.peek().left;
                int s2right = CUP$parser$stack.peek().right;
                Stmt s2 = CUP$parser$stack.peek().<Stmt> value();
                 RESULT = (If) new If(e, s1, s2).setLine(iright).setColumn(ileft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("if",29, CUP$parser$stack.elementAt(CUP$parser$top-4), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 60: // block ::= LBRACE stmts RBRACE 
            {
                Block RESULT = null;
                int lbleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int lbright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Object lb = CUP$parser$stack.elementAt(CUP$parser$top-2).<Object> value();
                int sleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int sright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                LinkedList<Stmt> s = CUP$parser$stack.elementAt(CUP$parser$top-1).<LinkedList<Stmt>> value();
                 RESULT = (Block) new Block(s).setLine(lbright).setColumn(lbleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("block",31, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 61: // block ::= LBRACE stmts return RBRACE 
            {
                Block RESULT = null;
                int lbleft = CUP$parser$stack.elementAt(CUP$parser$top-3).left;
                int lbright = CUP$parser$stack.elementAt(CUP$parser$top-3).right;
                Object lb = CUP$parser$stack.elementAt(CUP$parser$top-3).<Object> value();
                int sleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int sright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                LinkedList<Stmt> s = CUP$parser$stack.elementAt(CUP$parser$top-2).<LinkedList<Stmt>> value();
                int rleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int rright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Return r = CUP$parser$stack.elementAt(CUP$parser$top-1).<Return> value();
                 s.add(r); RESULT = (Block) new Block(s).setLine(lbright).setColumn(lbleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("block",31, CUP$parser$stack.elementAt(CUP$parser$top-3), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 62: // block ::= LBRACE return RBRACE 
            {
                Block RESULT = null;
                int lbleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int lbright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Object lb = CUP$parser$stack.elementAt(CUP$parser$top-2).<Object> value();
                int rleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int rright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Return r = CUP$parser$stack.elementAt(CUP$parser$top-1).<Return> value();
                 LinkedList<Stmt> lst = new LinkedList<Stmt>(); lst.add(r); RESULT = (Block) new Block(lst).setLine(lbright).setColumn(lbleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("block",31, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 63: // block ::= LBRACE RBRACE 
            {
                Block RESULT = null;
                int lbleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int lbright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Object lb = CUP$parser$stack.elementAt(CUP$parser$top-1).<Object> value();
                 RESULT = (Block) new Block(new LinkedList<Stmt>()).setLine(lbright).setColumn(lbleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("block",31, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 64: // expr ::= unop_expr 
            {
                Expr RESULT = null;
                int eleft = CUP$parser$stack.peek().left;
                int eright = CUP$parser$stack.peek().right;
                Unop e = CUP$parser$stack.peek().<Unop> value();
                 RESULT = e; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("expr",23, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 65: // expr ::= binop_expr 
            {
                Expr RESULT = null;
                int eleft = CUP$parser$stack.peek().left;
                int eright = CUP$parser$stack.peek().right;
                Binary e = CUP$parser$stack.peek().<Binary> value();
                 RESULT = e; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("expr",23, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 66: // expr ::= LPAREN expr RPAREN 
            {
                Expr RESULT = null;
                int eleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int eright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Expr e = CUP$parser$stack.elementAt(CUP$parser$top-1).<Expr> value();
                 RESULT = e; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("expr",23, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 67: // expr ::= id LPAREN arg RPAREN 
            {
                Expr RESULT = null;
                int idleft = CUP$parser$stack.elementAt(CUP$parser$top-3).left;
                int idright = CUP$parser$stack.elementAt(CUP$parser$top-3).right;
                Identifier id = CUP$parser$stack.elementAt(CUP$parser$top-3).<Identifier> value();
                int argleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int argright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                LinkedList<Expr> arg = CUP$parser$stack.elementAt(CUP$parser$top-1).<LinkedList<Expr>> value();
                 RESULT = new MethodCall(id, arg); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("expr",23, CUP$parser$stack.elementAt(CUP$parser$top-3), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 68: // expr ::= id LPAREN RPAREN 
            {
                Expr RESULT = null;
                int idleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int idright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Identifier id = CUP$parser$stack.elementAt(CUP$parser$top-2).<Identifier> value();
                 RESULT = new MethodCall(id, new LinkedList<Expr>()); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("expr",23, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 69: // expr ::= LENGTH LPAREN expr RPAREN 
            {
                Expr RESULT = null;
                int lleft = CUP$parser$stack.elementAt(CUP$parser$top-3).left;
                int lright = CUP$parser$stack.elementAt(CUP$parser$top-3).right;
                Object l = CUP$parser$stack.elementAt(CUP$parser$top-3).<Object> value();
                int eleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int eright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Expr e = CUP$parser$stack.elementAt(CUP$parser$top-1).<Expr> value();
                 LinkedList<Expr> lst = new LinkedList<Expr>(); lst.add(e);
                                                           Identifier len = (Identifier) new Identifier("length").setLine(lright).setColumn(lleft);
                                                           RESULT = new MethodCall(len, lst); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("expr",23, CUP$parser$stack.elementAt(CUP$parser$top-3), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 70: // expr ::= MINUS MIN_INT 
            {
                Expr RESULT = null;
                int uleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int uright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Object u = CUP$parser$stack.elementAt(CUP$parser$top-1).<Object> value();
                int nleft = CUP$parser$stack.peek().left;
                int nright = CUP$parser$stack.peek().right;
                Long n = CUP$parser$stack.peek().<Long> value();
                 RESULT = (Unop) new Negative((Int) new Int(n).setLine(nright).setColumn(nleft)).setLine(uright).setColumn(uleft);; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("expr",23, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 71: // expr ::= literal 
            {
                Expr RESULT = null;
                int lleft = CUP$parser$stack.peek().left;
                int lright = CUP$parser$stack.peek().right;
                Literal l = CUP$parser$stack.peek().<Literal> value();
                 RESULT = l; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("expr",23, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 72: // unop_expr ::= MINUS expr 
            {
                Unop RESULT = null;
                int uleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int uright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Object u = CUP$parser$stack.elementAt(CUP$parser$top-1).<Object> value();
                int e1left = CUP$parser$stack.peek().left;
                int e1right = CUP$parser$stack.peek().right;
                Expr e1 = CUP$parser$stack.peek().<Expr> value();
                 RESULT = (Unop) new Negative(e1).setLine(uright).setColumn(uleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("unop_expr",27, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 73: // unop_expr ::= NOT expr 
            {
                Unop RESULT = null;
                int uleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int uright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Object u = CUP$parser$stack.elementAt(CUP$parser$top-1).<Object> value();
                int e1left = CUP$parser$stack.peek().left;
                int e1right = CUP$parser$stack.peek().right;
                Expr e1 = CUP$parser$stack.peek().<Expr> value();
                 RESULT = (Unop) new Not(e1).setLine(uright).setColumn(uleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("unop_expr",27, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 74: // binop_expr ::= expr PLUS expr 
            {
                Binary RESULT = null;
                int e1left = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int e1right = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Expr e1 = CUP$parser$stack.elementAt(CUP$parser$top-2).<Expr> value();
                int e2left = CUP$parser$stack.peek().left;
                int e2right = CUP$parser$stack.peek().right;
                Expr e2 = CUP$parser$stack.peek().<Expr> value();
                 RESULT = new Plus(e1, e2); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("binop_expr",26, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 75: // binop_expr ::= expr MINUS expr 
            {
                Binary RESULT = null;
                int e1left = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int e1right = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Expr e1 = CUP$parser$stack.elementAt(CUP$parser$top-2).<Expr> value();
                int e2left = CUP$parser$stack.peek().left;
                int e2right = CUP$parser$stack.peek().right;
                Expr e2 = CUP$parser$stack.peek().<Expr> value();
                 RESULT = new Minus(e1, e2); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("binop_expr",26, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 76: // binop_expr ::= expr TIMES expr 
            {
                Binary RESULT = null;
                int e1left = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int e1right = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Expr e1 = CUP$parser$stack.elementAt(CUP$parser$top-2).<Expr> value();
                int e2left = CUP$parser$stack.peek().left;
                int e2right = CUP$parser$stack.peek().right;
                Expr e2 = CUP$parser$stack.peek().<Expr> value();
                 RESULT = new Times(e1, e2); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("binop_expr",26, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 77: // binop_expr ::= expr HTIMES expr 
            {
                Binary RESULT = null;
                int e1left = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int e1right = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Expr e1 = CUP$parser$stack.elementAt(CUP$parser$top-2).<Expr> value();
                int e2left = CUP$parser$stack.peek().left;
                int e2right = CUP$parser$stack.peek().right;
                Expr e2 = CUP$parser$stack.peek().<Expr> value();
                 RESULT = new HighTimes(e1, e2); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("binop_expr",26, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 78: // binop_expr ::= expr DIV expr 
            {
                Binary RESULT = null;
                int e1left = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int e1right = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Expr e1 = CUP$parser$stack.elementAt(CUP$parser$top-2).<Expr> value();
                int e2left = CUP$parser$stack.peek().left;
                int e2right = CUP$parser$stack.peek().right;
                Expr e2 = CUP$parser$stack.peek().<Expr> value();
                 RESULT = new Div(e1, e2); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("binop_expr",26, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 79: // binop_expr ::= expr MOD expr 
            {
                Binary RESULT = null;
                int e1left = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int e1right = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Expr e1 = CUP$parser$stack.elementAt(CUP$parser$top-2).<Expr> value();
                int e2left = CUP$parser$stack.peek().left;
                int e2right = CUP$parser$stack.peek().right;
                Expr e2 = CUP$parser$stack.peek().<Expr> value();
                 RESULT = new Mod(e1, e2); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("binop_expr",26, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 80: // binop_expr ::= expr LT expr 
            {
                Binary RESULT = null;
                int e1left = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int e1right = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Expr e1 = CUP$parser$stack.elementAt(CUP$parser$top-2).<Expr> value();
                int e2left = CUP$parser$stack.peek().left;
                int e2right = CUP$parser$stack.peek().right;
                Expr e2 = CUP$parser$stack.peek().<Expr> value();
                 RESULT = new LessThan(e1, e2); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("binop_expr",26, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 81: // binop_expr ::= expr LTE expr 
            {
                Binary RESULT = null;
                int e1left = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int e1right = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Expr e1 = CUP$parser$stack.elementAt(CUP$parser$top-2).<Expr> value();
                int e2left = CUP$parser$stack.peek().left;
                int e2right = CUP$parser$stack.peek().right;
                Expr e2 = CUP$parser$stack.peek().<Expr> value();
                 RESULT = new LessThanEqual(e1, e2); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("binop_expr",26, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 82: // binop_expr ::= expr GT expr 
            {
                Binary RESULT = null;
                int e1left = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int e1right = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Expr e1 = CUP$parser$stack.elementAt(CUP$parser$top-2).<Expr> value();
                int e2left = CUP$parser$stack.peek().left;
                int e2right = CUP$parser$stack.peek().right;
                Expr e2 = CUP$parser$stack.peek().<Expr> value();
                 RESULT = new GreaterThan(e1, e2); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("binop_expr",26, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 83: // binop_expr ::= expr GEQ expr 
            {
                Binary RESULT = null;
                int e1left = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int e1right = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Expr e1 = CUP$parser$stack.elementAt(CUP$parser$top-2).<Expr> value();
                int e2left = CUP$parser$stack.peek().left;
                int e2right = CUP$parser$stack.peek().right;
                Expr e2 = CUP$parser$stack.peek().<Expr> value();
                 RESULT = new GreaterThanEqual(e1, e2); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("binop_expr",26, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 84: // binop_expr ::= expr EQ expr 
            {
                Binary RESULT = null;
                int e1left = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int e1right = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Expr e1 = CUP$parser$stack.elementAt(CUP$parser$top-2).<Expr> value();
                int e2left = CUP$parser$stack.peek().left;
                int e2right = CUP$parser$stack.peek().right;
                Expr e2 = CUP$parser$stack.peek().<Expr> value();
                 RESULT = new Equal(e1, e2); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("binop_expr",26, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 85: // binop_expr ::= expr NEQ expr 
            {
                Binary RESULT = null;
                int e1left = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int e1right = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Expr e1 = CUP$parser$stack.elementAt(CUP$parser$top-2).<Expr> value();
                int e2left = CUP$parser$stack.peek().left;
                int e2right = CUP$parser$stack.peek().right;
                Expr e2 = CUP$parser$stack.peek().<Expr> value();
                 RESULT = new NotEqual(e1, e2); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("binop_expr",26, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 86: // binop_expr ::= expr AND expr 
            {
                Binary RESULT = null;
                int e1left = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int e1right = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Expr e1 = CUP$parser$stack.elementAt(CUP$parser$top-2).<Expr> value();
                int e2left = CUP$parser$stack.peek().left;
                int e2right = CUP$parser$stack.peek().right;
                Expr e2 = CUP$parser$stack.peek().<Expr> value();
                 RESULT = new And(e1, e2); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("binop_expr",26, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 87: // binop_expr ::= expr OR expr 
            {
                Binary RESULT = null;
                int e1left = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int e1right = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Expr e1 = CUP$parser$stack.elementAt(CUP$parser$top-2).<Expr> value();
                int e2left = CUP$parser$stack.peek().left;
                int e2right = CUP$parser$stack.peek().right;
                Expr e2 = CUP$parser$stack.peek().<Expr> value();
                 RESULT = new Or(e1, e2); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("binop_expr",26, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 88: // binop_expr ::= expr LBRACK expr RBRACK 
            {
                Binary RESULT = null;
                int e1left = CUP$parser$stack.elementAt(CUP$parser$top-3).left;
                int e1right = CUP$parser$stack.elementAt(CUP$parser$top-3).right;
                Expr e1 = CUP$parser$stack.elementAt(CUP$parser$top-3).<Expr> value();
                int e2left = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int e2right = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Expr e2 = CUP$parser$stack.elementAt(CUP$parser$top-1).<Expr> value();
                 RESULT = new ArrayAccess(e1, e2); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("binop_expr",26, CUP$parser$stack.elementAt(CUP$parser$top-3), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 89: // declaration ::= id COLON decl_type 
            {
                Declaration RESULT = null;
                int idleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int idright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Identifier id = CUP$parser$stack.elementAt(CUP$parser$top-2).<Identifier> value();
                int tleft = CUP$parser$stack.peek().left;
                int tright = CUP$parser$stack.peek().right;
                Type t = CUP$parser$stack.peek().<Type> value();
                 RESULT = new Declaration(id, t); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",18, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 90: // declarations ::= declarations COMMA id COLON type 
            {
                LinkedList<Variable> RESULT = null;
                int dsleft = CUP$parser$stack.elementAt(CUP$parser$top-4).left;
                int dsright = CUP$parser$stack.elementAt(CUP$parser$top-4).right;
                LinkedList<Variable> ds = CUP$parser$stack.elementAt(CUP$parser$top-4).<LinkedList<Variable>> value();
                int idleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int idright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Identifier id = CUP$parser$stack.elementAt(CUP$parser$top-2).<Identifier> value();
                int tleft = CUP$parser$stack.peek().left;
                int tright = CUP$parser$stack.peek().right;
                Type t = CUP$parser$stack.peek().<Type> value();
                 ds.add(new Declaration(id, t) ); RESULT = ds; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("declarations",19, CUP$parser$stack.elementAt(CUP$parser$top-4), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 91: // declarations ::= declarations COMMA id COLON type indices_empty 
            {
                LinkedList<Variable> RESULT = null;
                int dsleft = CUP$parser$stack.elementAt(CUP$parser$top-5).left;
                int dsright = CUP$parser$stack.elementAt(CUP$parser$top-5).right;
                LinkedList<Variable> ds = CUP$parser$stack.elementAt(CUP$parser$top-5).<LinkedList<Variable>> value();
                int idleft = CUP$parser$stack.elementAt(CUP$parser$top-3).left;
                int idright = CUP$parser$stack.elementAt(CUP$parser$top-3).right;
                Identifier id = CUP$parser$stack.elementAt(CUP$parser$top-3).<Identifier> value();
                int tleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int tright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Type t = CUP$parser$stack.elementAt(CUP$parser$top-1).<Type> value();
                int ileft = CUP$parser$stack.peek().left;
                int iright = CUP$parser$stack.peek().right;
                LinkedList<Expr> i = CUP$parser$stack.peek().<LinkedList<Expr>> value();
                 ds.add(new Declaration(id, ArrayType.fromList(t,i))); RESULT = ds; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("declarations",19, CUP$parser$stack.elementAt(CUP$parser$top-5), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 92: // declarations ::= declarations COMMA id indices_full 
            {
                LinkedList<Variable> RESULT = null;
                int dsleft = CUP$parser$stack.elementAt(CUP$parser$top-3).left;
                int dsright = CUP$parser$stack.elementAt(CUP$parser$top-3).right;
                LinkedList<Variable> ds = CUP$parser$stack.elementAt(CUP$parser$top-3).<LinkedList<Variable>> value();
                int idleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int idright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Identifier id = CUP$parser$stack.elementAt(CUP$parser$top-1).<Identifier> value();
                int lstleft = CUP$parser$stack.peek().left;
                int lstright = CUP$parser$stack.peek().right;
                LinkedList<Expr> lst = CUP$parser$stack.peek().<LinkedList<Expr>> value();
                 ds.add(ArrayAccess.fromList(id, lst)); RESULT = ds; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("declarations",19, CUP$parser$stack.elementAt(CUP$parser$top-3), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 93: // declarations ::= declarations COMMA USCORE 
            {
                LinkedList<Variable> RESULT = null;
                int dsleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int dsright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                LinkedList<Variable> ds = CUP$parser$stack.elementAt(CUP$parser$top-2).<LinkedList<Variable>> value();
                int uleft = CUP$parser$stack.peek().left;
                int uright = CUP$parser$stack.peek().right;
                Object u = CUP$parser$stack.peek().<Object> value();
                 ds.add((Variable) new UscoreDecl().setLine(uright).setColumn(uleft)); RESULT = ds; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("declarations",19, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 94: // declarations ::= USCORE 
            {
                LinkedList<Variable> RESULT = null;
                int uleft = CUP$parser$stack.peek().left;
                int uright = CUP$parser$stack.peek().right;
                Object u = CUP$parser$stack.peek().<Object> value();
                 LinkedList<Variable> lst = new LinkedList<Variable>(); lst.add((Variable) new UscoreDecl().setLine(uright).setColumn(uleft)); RESULT = lst; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("declarations",19, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 95: // declarations ::= id COLON type indices_empty 
            {
                LinkedList<Variable> RESULT = null;
                int idleft = CUP$parser$stack.elementAt(CUP$parser$top-3).left;
                int idright = CUP$parser$stack.elementAt(CUP$parser$top-3).right;
                Identifier id = CUP$parser$stack.elementAt(CUP$parser$top-3).<Identifier> value();
                int tleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int tright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Type t = CUP$parser$stack.elementAt(CUP$parser$top-1).<Type> value();
                int ileft = CUP$parser$stack.peek().left;
                int iright = CUP$parser$stack.peek().right;
                LinkedList<Expr> i = CUP$parser$stack.peek().<LinkedList<Expr>> value();
                 LinkedList<Variable> lst = new LinkedList<Variable>(); lst.add(new Declaration(id, ArrayType.fromList(t,i))); RESULT = lst; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("declarations",19, CUP$parser$stack.elementAt(CUP$parser$top-3), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 96: // declarations ::= id COLON type 
            {
                LinkedList<Variable> RESULT = null;
                int idleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int idright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Identifier id = CUP$parser$stack.elementAt(CUP$parser$top-2).<Identifier> value();
                int tleft = CUP$parser$stack.peek().left;
                int tright = CUP$parser$stack.peek().right;
                Type t = CUP$parser$stack.peek().<Type> value();
                 LinkedList<Variable> lst = new LinkedList<Variable>(); lst.add(new Declaration(id, t)); RESULT = lst; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("declarations",19, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 97: // assignment ::= variable ASSIGN expr 
            {
                Assignment RESULT = null;
                int vleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int vright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Variable v = CUP$parser$stack.elementAt(CUP$parser$top-2).<Variable> value();
                int eleft = CUP$parser$stack.peek().left;
                int eright = CUP$parser$stack.peek().right;
                Expr e = CUP$parser$stack.peek().<Expr> value();
                 LinkedList<Variable> lst = new LinkedList<Variable>(); lst.add(v); RESULT = new Assignment(lst, e); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("assignment",28, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 98: // assignment ::= declarations ASSIGN expr 
            {
                Assignment RESULT = null;
                int dsleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int dsright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                LinkedList<Variable> ds = CUP$parser$stack.elementAt(CUP$parser$top-2).<LinkedList<Variable>> value();
                int eleft = CUP$parser$stack.peek().left;
                int eright = CUP$parser$stack.peek().right;
                Expr e = CUP$parser$stack.peek().<Expr> value();
                 RESULT = new Assignment(ds, e); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("assignment",28, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 99: // variable ::= id 
            {
                Variable RESULT = null;
                int idleft = CUP$parser$stack.peek().left;
                int idright = CUP$parser$stack.peek().right;
                Identifier id = CUP$parser$stack.peek().<Identifier> value();
                 RESULT = id; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("variable",33, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 100: // variable ::= variable LBRACK expr RBRACK 
            {
                Variable RESULT = null;
                int vleft = CUP$parser$stack.elementAt(CUP$parser$top-3).left;
                int vright = CUP$parser$stack.elementAt(CUP$parser$top-3).right;
                Variable v = CUP$parser$stack.elementAt(CUP$parser$top-3).<Variable> value();
                int eleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int eright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Expr e = CUP$parser$stack.elementAt(CUP$parser$top-1).<Expr> value();
                 RESULT = new ArrayAccess(v, e); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("variable",33, CUP$parser$stack.elementAt(CUP$parser$top-3), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 101: // variable ::= id LPAREN arg RPAREN LBRACK expr RBRACK 
            {
                Variable RESULT = null;
                int idleft = CUP$parser$stack.elementAt(CUP$parser$top-6).left;
                int idright = CUP$parser$stack.elementAt(CUP$parser$top-6).right;
                Identifier id = CUP$parser$stack.elementAt(CUP$parser$top-6).<Identifier> value();
                int argleft = CUP$parser$stack.elementAt(CUP$parser$top-4).left;
                int argright = CUP$parser$stack.elementAt(CUP$parser$top-4).right;
                LinkedList<Expr> arg = CUP$parser$stack.elementAt(CUP$parser$top-4).<LinkedList<Expr>> value();
                int eleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int eright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Expr e = CUP$parser$stack.elementAt(CUP$parser$top-1).<Expr> value();
                 RESULT = new ArrayAccess(new MethodCall(id, arg), e); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("variable",33, CUP$parser$stack.elementAt(CUP$parser$top-6), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 102: // variable ::= id LPAREN RPAREN LBRACK expr RBRACK 
            {
                Variable RESULT = null;
                int idleft = CUP$parser$stack.elementAt(CUP$parser$top-5).left;
                int idright = CUP$parser$stack.elementAt(CUP$parser$top-5).right;
                Identifier id = CUP$parser$stack.elementAt(CUP$parser$top-5).<Identifier> value();
                int eleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int eright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Expr e = CUP$parser$stack.elementAt(CUP$parser$top-1).<Expr> value();
                 RESULT = new ArrayAccess(new MethodCall(id, new LinkedList<Expr>()), e); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("variable",33, CUP$parser$stack.elementAt(CUP$parser$top-5), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 103: // literal ::= TRUE 
            {
                Literal RESULT = null;
                int bleft = CUP$parser$stack.peek().left;
                int bright = CUP$parser$stack.peek().right;
                Object b = CUP$parser$stack.peek().<Object> value();
                 RESULT = (Bool) new Bool(true).setLine(bright).setColumn(bleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("literal",32, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 104: // literal ::= FALSE 
            {
                Literal RESULT = null;
                int bleft = CUP$parser$stack.peek().left;
                int bright = CUP$parser$stack.peek().right;
                Object b = CUP$parser$stack.peek().<Object> value();
                 RESULT = (Bool) new Bool(false).setLine(bright).setColumn(bleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("literal",32, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 105: // literal ::= INT 
            {
                Literal RESULT = null;
                int nleft = CUP$parser$stack.peek().left;
                int nright = CUP$parser$stack.peek().right;
                Long n = CUP$parser$stack.peek().<Long> value();
                 RESULT = (Int) new Int(n).setLine(nright).setColumn(nleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("literal",32, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 106: // literal ::= STRING 
            {
                Literal RESULT = null;
                int sleft = CUP$parser$stack.peek().left;
                int sright = CUP$parser$stack.peek().right;
                String s = CUP$parser$stack.peek().<String> value();
                 RESULT = (StringLit) new StringLit(s).setLine(sright).setColumn(sleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("literal",32, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 107: // literal ::= CHAR 
            {
                Literal RESULT = null;
                int cleft = CUP$parser$stack.peek().left;
                int cright = CUP$parser$stack.peek().right;
                String c = CUP$parser$stack.peek().<String> value();
                 RESULT = (Char) new Char(c).setLine(cright).setColumn(cleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("literal",32, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 108: // literal ::= id 
            {
                Literal RESULT = null;
                int idleft = CUP$parser$stack.peek().left;
                int idright = CUP$parser$stack.peek().right;
                Identifier id = CUP$parser$stack.peek().<Identifier> value();
                 RESULT = id; 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("literal",32, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 109: // literal ::= LBRACE arg RBRACE 
            {
                Literal RESULT = null;
                int lbleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int lbright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Object lb = CUP$parser$stack.elementAt(CUP$parser$top-2).<Object> value();
                int argleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int argright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                LinkedList<Expr> arg = CUP$parser$stack.elementAt(CUP$parser$top-1).<LinkedList<Expr>> value();
                 RESULT = (ArrayLit) new ArrayLit(arg).setLine(lbright).setColumn(lbleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("literal",32, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 110: // literal ::= LBRACE RBRACE 
            {
                Literal RESULT = null;
                int lbleft = CUP$parser$stack.elementAt(CUP$parser$top-1).left;
                int lbright = CUP$parser$stack.elementAt(CUP$parser$top-1).right;
                Object lb = CUP$parser$stack.elementAt(CUP$parser$top-1).<Object> value();
                 RESULT = (ArrayLit) new ArrayLit(new LinkedList<Expr>()).setLine(lbright).setColumn(lbleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("literal",32, CUP$parser$stack.elementAt(CUP$parser$top-1), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 111: // literal ::= LBRACE COMMA RBRACE 
            {
                Literal RESULT = null;
                int lbleft = CUP$parser$stack.elementAt(CUP$parser$top-2).left;
                int lbright = CUP$parser$stack.elementAt(CUP$parser$top-2).right;
                Object lb = CUP$parser$stack.elementAt(CUP$parser$top-2).<Object> value();
                 RESULT = (ArrayLit) new ArrayLit(new LinkedList<Expr>()).setLine(lbright).setColumn(lbleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("literal",32, CUP$parser$stack.elementAt(CUP$parser$top-2), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 112: // id ::= ID 
            {
                Identifier RESULT = null;
                int idleft = CUP$parser$stack.peek().left;
                int idright = CUP$parser$stack.peek().right;
                String id = CUP$parser$stack.peek().<String> value();
                 RESULT = (Identifier) new Identifier(id).setLine(idright).setColumn(idleft); 
                CUP$parser$result = parser.getSymbolFactory().newSymbol("id",34, CUP$parser$stack.peek(), CUP$parser$stack.peek(), RESULT);
            }
            return CUP$parser$result;

        /* . . . . . .*/
        default:
            throw new Exception(
                  "Invalid action number " + CUP$parser$act_num + " found in internal parse table");

        }
    } /* end of method */

    /** Method splitting the generated action code into several parts. */
    public final java_cup.runtime.Symbol CUP$parser$do_action(
            int                        CUP$parser$act_num,
            java_cup.runtime.lr_parser CUP$parser$parser,
            java.util.Stack<java_cup.runtime.Symbol> CUP$parser$stack,
            int                        CUP$parser$top)
            throws java.lang.Exception {
            return CUP$parser$do_action_part00000000(
                           CUP$parser$act_num,
                           CUP$parser$parser,
                           CUP$parser$stack,
                           CUP$parser$top);
    }
}

}
